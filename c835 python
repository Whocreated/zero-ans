import sys
from typing import List, Tuple, Dict
# 設定遞歸深度以防萬一
# sys.setrecursionlimit(2000)

# 使用 lld = int
lld = int
INF = 1 << 30

# 離散化結構 Z3
class Z3:
    """
    將尺寸/指數值進行離散化和索引映射。
    """
    def __init__(self):
        self.vv: List[int] = []

    def init(self):
        self.vv.clear()

    def insert(self, x: int):
        self.vv.append(x)

    def done(self):
        # 排序
        self.vv.sort()
        # 移除重複項
        unique_vv = []
        if self.vv:
            unique_vv.append(self.vv[0])
            for i in range(1, len(self.vv)):
                if self.vv[i] != self.vv[i-1]:
                    unique_vv.append(self.vv[i])
        self.vv = unique_vv

    def sz(self) -> int:
        return len(self.vv)

    def get(self, x: int) -> int:
        # 使用二分查找 (lower_bound) 找到 x 應該插入的位置
        import bisect
        return bisect.bisect_left(self.vv, x)

    def inv_get(self, x: int) -> int:
        # 取得索引 x 對應的實際值
        return self.vv[x]

def solve():
    # 讀取輸入，優化 I/O
    # 將 stdin 緩衝區設為較快的讀取方式
    input = sys.stdin.read
    data = input().split()
    if not data:
        return

    n = int(data[0])
    m = int(data[1])
    
    arr: List[Tuple[int, lld]] = []
    
    # 讀取物品數據
    data_idx = 2
    for i in range(n):
        w = int(data[data_idx])
        v = lld(data[data_idx + 1])
        arr.append((w, v))
        data_idx += 2
        
    # Step 1: 排序 (按尺寸等級 w 降序)
    # 原始 C++ 程式碼中，arr 是按 w 降序排序的
    arr.sort(key=lambda x: x[0], reverse=True)
    
    # Step 2: 離散化
    z3 = Z3()
    for w, v in arr:
        z3.insert(w)
    z3.insert(m)
    z3.done()
    
    # 初始化 q1, q2 (使用列表的列表來模擬 C++ 的數組，但索引會映射到離散化後的尺寸等級)
    size_z3 = z3.sz()
    q1: List[List[lld]] = [[] for _ in range(size_z3)]  # 原始物品
    q2: List[List[lld]] = [[] for _ in range(size_z3)]  # 合併/組合後的物品

    # 將目標 m 設置為初始狀態 (大小為 m 的容量，價值為 0)
    # 這一步在 C++ 程式碼中是為了確保 dp 的起點
    q1[z3.get(m)].append(0)

    # 將原始物品按尺寸等級分組並放入 q1
    for w, v in arr:
        # 由於 arr 已經按 w 降序排序，這裡插入 q1[i] 的元素也是降序的
        q1[z3.get(w)].append(v)
        
    # Step 3: 動態合併 (DP 轉移)
    # i 遍歷所有尺寸等級的索引，從最小到最大 (不包括 m 所在的索引)
    for i in range(size_z3 - 1):
        # 如果當前尺寸等級已經是目標 m 的等級，則停止
        if z3.inv_get(i) == m:
            break
            
        # 兩個列表（q1[i] 原始物品, q2[i] 合併物品）都是按價值降序排列的
        
        # 合併 q1[i] 和 q2[i] 到 cur (Merge Sort)
        cur: List[lld] = []
        pt1, pt2 = 0, 0
        list1, list2 = q1[i], q2[i]
        
        while pt1 < len(list1) and pt2 < len(list2):
            if list1[pt1] > list2[pt2]:
                cur.append(list1[pt1])
                pt1 += 1
            else:
                cur.append(list2[pt2])
                pt2 += 1
                
        cur.extend(list1[pt1:])
        cur.extend(list2[pt2:])
        
        # 接下來是按組 bk 進行合併，轉移到 i + 1 級
        
        # lgp = 指數差: w_{i+1} - w_i
        lgp = z3.inv_get(i + 1) - z3.inv_get(i)
        
        # bk = 2^lgp：表示 i 級的物品需要多少個才能組成 i+1 級的尺寸
        bk = (1 << lgp) if lgp <= 20 else INF
        
        curl = len(cur)
        
        # 每 bk 個一組，計算總價值 v，並將 v 放入下一等級 q2[i+1]
        for _ in range(0, curl, bk):
            v = 0
            # 計算當前組 (大小為 bk) 的總價值
            for j in range(bk):
                if _ + j >= curl:
                    break
                v += cur[_ + j]
            
            # 將總價值 v 作為一個新的組合放入下一等級
            q2[i + 1].append(v)

    # Step 4: 找出最大答案
    ans: lld = 0
    z3m = z3.get(m)
    
    # 最終答案位於目標尺寸 m 對應的索引 z3m
    # 由於 q1 和 q2 都是降序排列的，只需檢查第一個元素
    
    if q1[z3m]:
        ans = max(ans, q1[z3m][0])
        
    if q2[z3m]:
        ans = max(ans, q2[z3m][0])
        
    print(ans)

if __name__ == "__main__":
    # 為了模擬 C++ 的快速 I/O 和單次運行，使用 solve() 函數封裝
    solve()
