import java.util.*;
import java.io.*;

public class OptimizedKnapsackDP {

    // 定義 Item 類別 (等同於 C++ 的 pair<int, lld>)
    static class Item {
        int exponent; // 對應 arr[i].first
        long value;  // 對應 arr[i].second

        public Item(int exponent, long value) {
            this.exponent = exponent;
            this.value = value;
        }
    }

    // 離散化工具類別 (等同於 C++ 的 struct Z3)
    static class Discretizer {
        private final List<Integer> vv = new ArrayList<>();

        public void init() {
            vv.clear();
        }

        public void insert(int x) {
            vv.add(x);
        }

        public void done() {
            // 排序
            Collections.sort(vv);
            
            // 去重 (Resize the list to the size of unique elements)
            List<Integer> uniqueList = new ArrayList<>();
            if (!vv.isEmpty()) {
                uniqueList.add(vv.get(0));
                for (int i = 1; i < vv.size(); i++) {
                    if (!vv.get(i).equals(vv.get(i - 1))) {
                        uniqueList.add(vv.get(i));
                    }
                }
            }
            vv.clear();
            vv.addAll(uniqueList);
        }

        public int size() {
            return vv.size();
        }

        // 查找元素 x 在離散化陣列中的索引 (0-based)
        public int get(int x) {
            // 使用二分搜索找到第一個大於或等於 x 的元素
            int index = Collections.binarySearch(vv, x);
            if (index < 0) {
                // 如果找不到，Collections.binarySearch 返回 -(insertionPoint) - 1
                // insertionPoint 就是 lower_bound 的位置
                index = -index - 1;
            }
            return index;
        }

        // 根據索引查找原始值
        public int invGet(int x) {
            return vv.get(x);
        }
    }

    // 常數定義
    private static final int N_MAX = 1000000 + 5;
    private static final int INF = 1 << 30; // 2^30

    public static void main(String[] args) throws IOException {
        // Fast I/O
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);

        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken()); // m 可能是某種容量或最大指數

        Item[] arr = new Item[n];
        for (int i = 0; i < n; i++) {
            st = new StringTokenizer(br.readLine());
            arr[i] = new Item(Integer.parseInt(st.nextToken()), Long.parseLong(st.nextToken()));
        }

        // 1. 排序 (Sort and Reverse): 關鍵步驟，通常是為了貪婪選擇
        // 按照 exponent 降序排序
        Arrays.sort(arr, (a, b) -> Integer.compare(b.exponent, a.exponent));

        // 2. 離散化 (Discretization)
        Discretizer z3 = new Discretizer();
        for (int i = 0; i < n; i++) {
            z3.insert(arr[i].exponent);
        }
        z3.insert(m); // 將容量/最大指數 m 也加入離散化
        z3.done();

        // 3. 初始化 DP 陣列 (q1, q2)
        // q1[i] 存儲原始物品的價值 (按降序排列)
        // q2[i] 存儲從較小組 (i-1) 合併過來的價值 (按降序排列)
        // N_MAX used here is actually z3.size() at max, but we use the general limit
        List<Long>[] q1 = new ArrayList[z3.size()];
        List<Long>[] q2 = new ArrayList[z3.size()];
        for (int i = 0; i < z3.size(); i++) {
            q1[i] = new ArrayList<>();
            q2[i] = new ArrayList<>();
        }

        // 填充 q1: 將價值按 exponent 進行分組
        // q1[z3.get(m)] 被賦予 0 作為起點
        q1[z3.get(m)].add(0L); 
        for (int i = 0; i < n; i++) {
            q1[z3.get(arr[i].exponent)].add(arr[i].value);
        }
        
        // 對 q1 中的每個列表，按價值降序排序
        for (List<Long> list : q1) {
            list.sort(Comparator.reverseOrder());
        }

        // 4. DP 狀態轉移：優化合併 (Merge Operation)
        for (int i = 0; i + 1 < z3.size(); i++) {
            if (z3.invGet(i) == m) break; // 達到最大指數 m，停止

            // 步驟 A: 合併 q1[i] 和 q2[i] 成 cur (標準 Two-pointer Merge Sort 合併)
            List<Long> cur = new ArrayList<>();
            int pt1 = 0, pt2 = 0;
            // q1 和 q2 都是降序排列的，因此直接合併
            while (pt1 < q1[i].size() && pt2 < q2[i].size()) {
                if (q1[i].get(pt1) > q2[i].get(pt2)) {
                    cur.add(q1[i].get(pt1++));
                } else {
                    cur.add(q2[i].get(pt2++));
                }
            }
            while (pt1 < q1[i].size()) cur.add(q1[i].get(pt1++));
            while (pt2 < q2[i].size()) cur.add(q2[i].get(pt2++));

            // 步驟 B: 分組求和並轉移到 q2[i+1] (優化合併)
            
            // lgp: 下一個指數級別與當前指數級別的差值
            int lgp = z3.invGet(i + 1) - z3.invGet(i); 
            
            // bk: 分組大小 (2^lgp)
            int bk = (lgp <= 30) ? (1 << lgp) : INF; 
            int curl = cur.size();

            // 每 bk 個價值進行一次求和，並將結果存入 q2[i+1]
            for (int _ = 0; _ < curl; _ += bk) {
                long v = 0;
                for (int j = 0; j < bk; j++) {
                    if (_ + j == curl) break;
                    v += cur.get(_ + j); // 累積價值
                }
                q2[i + 1].add(v); // 轉移到下一個離散化組
            }
            
            // q2[i+1] 繼承了 cur 的降序特性，因此不需要再次排序。
        }

        // 5. 找出最終答案 (Result)
        long ans = 0;
        int z3m = z3.get(m);

        // 答案是 q1[z3m] 和 q2[z3m] 中最大的那個元素 (通常在第一個位置，因為都是降序排列)
        if (!q1[z3m].isEmpty()) {
            ans = Math.max(ans, q1[z3m].get(0));
        }
        if (!q2[z3m].isEmpty()) {
            ans = Math.max(ans, q2[z3m].get(0));
        }

        // 輸出結果
        pw.println(ans);
        pw.flush();
    }
}
